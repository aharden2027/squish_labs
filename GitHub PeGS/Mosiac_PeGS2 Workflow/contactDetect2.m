% contactDetect2.m
% ------------------------------------------------------------
%   This function prepares particle data for contact force analysis by:
%     1. Loading particle position data from 'particle_positions.txt'
%     2. Cleaning particles near image edges using a radius-based margin
%     3. Optionally backing up the uncleaned data
%     4. Setting parameters for contact detection
%     5. Calling the downstream analysis function `contactDetect_fix`
%
%   It ensures that only particles fully within image bounds (with a safety
%   margin) are retained, reducing errors during force computation or cropping.
%
% USAGE:
%   contactDetect2(fileParams, cdParams)
%
% INPUTS:
%   fileParams - Struct containing file directory and naming settings:
%                • topDir: base path
%                • imgDir: subdirectory with image files
%                • imgReg: image filename pattern (e.g. '*.png')
%
%   cdParams   - Struct of contact detection parameters, including:
%                • CR: crop radius margin (px)
%                • (others for g²-force and visualization, reinitialized inside)
%
% OUTPUT:
%   • Overwrites 'particle_positions.txt' with cleaned version
%   • Optionally saves backup of original file in 'particle_positions_backups/'
%   • Launches contactDetect_fix with updated parameters
%
% DEPENDENCIES:
%   Requires:
%     - 'particle_positions.txt' generated by preserveParticleID.m
%     - contactDetect_fix.m
%
% NOTE:
%   This script partially reinitializes `cdParams` internally and assumes a fixed
%   calibration and physical interpretation of particle forces. The crop radius
%   (CR) must be consistent across all uses.function contactDetect2(fileParams, cdParams)
% 
% Authors: [Vir Goyal, Arno Harden, Ashe Tanemura]
% Last updated: [6/20/2025]
% -----------------------------------------------------------------------------

function contactDetect2(fileParams, cdParams, verbose)
    fprintf("\n")
    % 1. File‑system parameters
    make_backup = false; % save uncleaned particle_positions.txt file to particle_positions_backups
    
    % 2. Load particle_positions.txt produced by preseservePaticleID.m
    
    particleFile = fullfile(fileParams.topDir,'particle_positions.txt');
    if ~exist(particleFile,'file')
        error('particle_positions.txt not found – run preseservePaticleID.m first');
    end
    particles = readmatrix(particleFile);
    fprintf('Loaded %d particle rows from particle_positions.txt\n',size(particles,1));
    
    % 3. Smart edge cleaner: drop any particle that contactDetect cannot crop
    
    CR = cdParams.CR;          % *must* match cdParams.CR below
    fprintf('Running edge cleaner (margin = radius + %d px) …\n', cdParams.CR);
    
    imgFiles = dir(fullfile(fileParams.topDir,fileParams.imgDir,fileParams.imgReg));
    if isempty(imgFiles)
        error('No image files found in %s',fileParams.imgDir);
    end
    
    % Cache per‑image sizes [H W]
    imgSize = zeros(numel(imgFiles),2);
    for k = 1:numel(imgFiles)
        I = imread(fullfile(imgFiles(k).folder,imgFiles(k).name));
        imgSize(k,:) = size(I,[1 2]);     % [rows cols]
    end
    
    frames = particles(:,1);   % frame index assigned earlier
    x      = particles(:,3);
    y      = particles(:,4);
    r      = particles(:,5);
    
    keep = true(size(particles,1),1);
    for i = 1:size(particles,1)
        f = frames(i);
        if f<1 || f>numel(imgFiles)
            warning('Frame %d outside image list – dropping particle',f);
            keep(i) = false; continue; end
        H = imgSize(f,1); W = imgSize(f,2);
        % replicate the exact inequalities in contactDetect (rounded) and add ± CR
        if  round(y(i)+r(i)) > H-1 || round(x(i)+r(i)) > W-1 || ...
            round(y(i)-r(i)) < 2   || round(x(i)-r(i)) < 2   || ...
            (y(i)+r(i)+CR)   > H   || (x(i)+r(i)+CR) > W     || ...
            (y(i)-r(i)-CR)   < 1   || (x(i)-r(i)-CR) < 1
            keep(i) = false;
        end
    end
    
    cleanedParticles = particles(keep,:);
    fprintf('Edge cleaner: kept %d / %d particles (%.1f%%)\n',sum(keep),numel(keep),100*sum(keep)/numel(keep));
    
    % Backup original and overwrite with cleaned list
    mainOutDir = 'testdata';
    backupOutDir = fullfile(mainOutDir, 'particle_positions_backups');
    
    if ~exist(backupOutDir, 'dir')
        mkdir(backupOutDir);
    end
    
    [~, name, ext] = fileparts(particleFile);
    backupFile = fullfile(backupOutDir, [name ext '.backup_' datestr(now,'yyyymmdd_HHMMSS')]);
    % saving backup if desired
    if make_backup
        copyfile(particleFile,backupFile);
        writematrix(cleanedParticles,particleFile);
        fprintf('Wrote cleaned particle list; backup saved to\n   %s\n',backupFile);
    else
        writematrix(cleanedParticles,particleFile);
        fprintf('Wrote cleaned particle list \n');
    end
    
    % cdParams = struct();
    % cdParams.metersperpixel       = 0.007/160;  % your calibration
    % cdParams.fsigma               = 140;        % PE stress coefficient
    % cdParams.g2cal                = 100;        % g²→force calibration
    % cdParams.dtol                 = 10;         % neighbour distance tol (px)
    % cdParams.contactG2Threshold   = 0.5;        % minimal g² in contact area
    % cdParams.CR                   = CR;         % *** keep equal to CR above ***
    % cdParams.imadjust_limits      = [0 0.65];   % contrast stretch for green ch.
    % cdParams.rednormal            = 2;          % red‑leak subtraction factor
    % cdParams.figverbose= true;                  % show figures & save JPGs
    
    % 4. Launch contactDetect_fix (changed)
    
    fprintf('Calling contactDetect_fix …\n');
    try
        contactDetect_fix(fileParams,cdParams,verbose);   % true = verbose wrapper
        fprintf('contactDetect_fix finished successfully.\n');
    catch ME
        fprintf(2,'contactDetect_fix crashed: %s\n',ME.message);
        rethrow(ME);
    end
end 

